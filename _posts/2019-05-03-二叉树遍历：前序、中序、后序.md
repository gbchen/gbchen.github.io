---
layout:     post
title:      二叉树遍历：前序、中序、后序
subtitle:   二叉树遍历：leetCode  144，145，94。
date:       2019-05-03
author:     CHEN
header-img: img/post-bg-debug.png
catalog: true
tags:
    - 二叉树
    - 算法
    - java
    - 层序遍历
---

# 概念
>所谓的二叉树前序遍历、中序遍历、后序遍历，用一句话解释就是，父节点的遍历顺序在哪？
>
>前序遍历就是：父、左、右。
>
>中序遍历就是：左、父、右。
>
>后序遍历就是：左、右、父。

例子：

```java
二叉树结构： 
   1
    \
     2
    /
   3 

前序遍历: [1,2,3]
中序遍历：[1,3,2]
后序遍历：[3,2,1]
```

节点结构：
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
```

LeetCode上如果用递归，很简单可以完成，但是进阶一点就是用迭代来完成。

# 递归解法
可以看到递归解法很简单，只不过是替换了下函数的调用顺序。
## 二叉树的前序遍历
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preorderTraversalInter(result, root);
        return result;
    }

    private void preorderTraversalInter(List<Integer> result, TreeNode root) {
        if (root == null){
            return ;
        }
        result.add(root.val);
        preorderTraversalInter(result, root.left);
        preorderTraversalInter(result, root.right);
    }
}
```
## 二叉树的后序遍历
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postorderTraversalInter(result, root);
        return result;
    }
    private void postorderTraversalInter(List<Integer> result, TreeNode root) {
        if (root == null){
            return ;
        }
        postorderTraversalInter(result, root.left);
        postorderTraversalInter(result, root.right);
        result.add(root.val);
    }
}
```
##二叉树的中序遍历
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inorderTraversalInter(result, root);
        return result;
    }
    private void inorderTraversalInter(List<Integer> result, TreeNode root) {
        if (root == null){
            return ;
        }
        inorderTraversalInter(result, root.left);
        result.add(root.val);
        inorderTraversalInter(result, root.right);
    }
}
```

# 迭代解法
## 二叉树的前序遍历
父节点是先读出的，所以父节点值先取出，然后将右、左加到栈里面。
弹出元素之后重复以上操作。
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode p = stack.pop();
            if (p != null){
                //先序，也就是先把父节点读出
                list.add(p.val);
                //然后分别将右和左压入栈，出栈刚好是先左后右
                stack.push(p.right);
                stack.push(p.left);
            }
        }
        return list;
    }
}
```
## 二叉树的后序遍历
父节点是最后读出的。可以反向思维，结合先序遍历。
调整压栈顺序，之后把答案反转即可。
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<Integer>();
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode p = stack.pop();
            if (p != null){
                list.add(p.val);
                stack.push(p.left);
                stack.push(p.right);
            }
        }
        Collections.reverse(list);
        return list;
    }
}
```
##二叉树的中序遍历
父节点读出之前，一定要保证所有左孩子都读完。
所以父节点压栈，然后将左孩子压栈。
弹栈之后，将右孩子压栈。
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            list.add(root.val);
            root = root.right;
        }
        return list;
    }
}
```



